#lang racket

(require "sigs-structs.rkt")
(require "breaks.rkt")
(require "lang/ast.rkt")
(require "lang/bounds.rkt")
(require "shared.rkt"
         "last-checker.rkt"
         "translate-to-kodkod-cli.rkt"
         "translate-from-kodkod-cli.rkt")
(require (prefix-in @ (only-in racket and or not = > < >= <= -)))
(require (prefix-in pardinus: "pardinus-cli/server/kks.rkt")
         (prefix-in pardinus: "pardinus-cli/server/server.rkt")
         (prefix-in pardinus: "pardinus-cli/server/server-common.rkt"))
(require (prefix-in kodkod: "kodkod-cli/server/kks.rkt")
         (prefix-in kodkod: "kodkod-cli/server/server.rkt")
         (prefix-in kodkod: "kodkod-cli/server/server-common.rkt"))
(require "server/eval-model.rkt")
(require "drracket-gui.rkt")

(provide send-to-kodkod)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;    Run Logic    ;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; send-to-kodkod :: Run-spec -> Stream<model>, List<Symbol>
; Given a Run-spec structure, processes the data and communicates it to KodKod-CLI;
; then produces a stream to produce instances generated by KodKod, 
; along with a list of all of the atom names for sig atoms.
(define (send-to-kodkod run-spec)
  ; Do relation breaks from declarations
  (define relation-constraints 
    (apply append
           (for/list ([relation (get-relations run-spec)])
             (match (Relation-breaker relation)
               [#f (list)]
               ['default (list)]
               ['pfunc (let* ([rel (Relation-rel relation)]
                              [sigs (Relation-sigs relation)]
                              [left-sig (get-sig run-spec (first sigs))]
                              [sig-rel (Sig-rel left-sig)])
                         (list (all ([s sig-rel])
                                 (lone (join s rel)))))]
               [other (break (Relation-rel relation) other)
                      (list)]))))

  ; Insert missing upper bounds of partial bindings
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))
  (define fixed-sigs
    (for/hash ([(rel pbinding) (in-hash pbindings)])      
      (match-define (sbound rel lower upper) pbinding)
      (when (@and (@= (relation-arity rel) 1) (@not upper))
        (define sig (get-sig run-spec (string->symbol (relation-name rel))))
        (define sig-scope (get-scope run-spec sig))
        (define new-atoms (range (set-count lower) (Range-upper sig-scope)))
        (define new-names (map (lambda (n) (list (string->symbol (format "~a~a" (Sig-name sig) n)))) new-atoms))
        (define new-upper (set-union lower (list->set new-names)))
        (set! upper new-upper))
      (values rel (sbound rel lower upper))))
  
  (define fixed-relations
    (for/hash ([(rel pbinding) (in-hash fixed-sigs)])
      (match-define (sbound rel lower upper) pbinding)
      (when (@and (@> (relation-arity rel) 1) (@not upper))
        (define relation (get-relation run-spec (string->symbol (relation-name rel))))
        (define types (get-sigs run-spec relation))
        (define type-uppers (map (compose set->list
                                          sbound-upper
                                          (curry hash-ref fixed-sigs ))
                                 types))
        (define new-upper (list->set (apply cartesian-product type-uppers)))
        (set! upper new-upper))
      (values rel (sbound rel lower upper))))
  
  (set! pbindings fixed-relations)
  ; Send user defined partial bindings to breaks
  (map instance (hash-values pbindings))

  (define tbindings 
    (let* ([init-tbindings (Bound-tbindings (Run-spec-bounds run-spec))]
           [fixed-init-tbindings (hash-remove (hash-remove init-tbindings 'Int) 'succ)])
      (for/fold ([tbindings fixed-init-tbindings])
                ([(rel sb) (in-hash pbindings)])
        ; this nonsense is just for atom names
        (define name (string->symbol (relation-name rel)))
        (hash-set tbindings name (for/list ([tup (sbound-upper sb)]) (car tup))))))

  ; Get KodKod names, min sets, and max sets of Sigs and Relations
  (define-values (sig-to-bound all-atoms) ; Map<Symbol, bound>, List<Symbol>
    (get-sig-bounds run-spec tbindings))

  (define relation-to-bound ; Map<Symbol, bound>
    (get-relation-bounds run-spec sig-to-bound))
  
  ; Get new bounds and constraints from breaks
  (define-values (total-bounds break-preds)
    (let* ([sig-bounds (map (compose (curry hash-ref sig-to-bound )
                                     Sig-name)
                            (get-sigs run-spec))]
           [relation-bounds (map (compose (curry hash-ref relation-to-bound )
                                          Relation-name)
                                 (get-relations run-spec))]
           [total-bounds (append sig-bounds relation-bounds)]
           [sigs (get-sigs run-spec)]
           [sig-rels (map Sig-rel (filter (lambda (sig) (@not (equal? (Sig-name sig) 'Int))) sigs))]
           [upper-bounds (for/hash ([sig sigs]) 
                           (values (Sig-rel sig) 
                                   (map car (bound-upper (hash-ref sig-to-bound (Sig-name sig))))))]
           [relations-store (for/hash ([relation (get-relations run-spec)]
                                       #:unless (equal? (Relation-name relation) 'succ))
                              (values (Relation-rel relation) (map Sig-rel (get-sigs run-spec relation))))]
           [extensions-store (for/hash ([sig sigs]
                                        #:when (Sig-extends sig))
                               (values (Sig-rel sig) (Sig-rel (get-sig run-spec (Sig-extends sig)))))])
      (constrain-bounds total-bounds sig-rels upper-bounds relations-store extensions-store)))
  (clear-breaker-state)

  (define sigs-and-rels
    (append (State-sig-order (Run-spec-state run-spec))
            (State-relation-order (Run-spec-state run-spec))))
  (set! total-bounds (map (lambda (name) 
                            (findf (lambda (b) 
                                     (equal? name (string->symbol (relation-name (bound-relation b)))))
                                   total-bounds)) 
                          sigs-and-rels))

  (when (@>= (get-verbosity) VERBOSITY_DEBUG)
    (displayln "--------------------------")
    (printf "Original PBindings: ~n~a~n~n" (Bound-pbindings (Run-spec-bounds run-spec)))
    (printf "Fixed PBindings: ~n~a~n~n" pbindings)
    (printf "Original TBindings: ~n~a~n~n" (Bound-tbindings (Run-spec-bounds run-spec)))
    (printf "Fixed TBindings: ~n~a~n~n" tbindings)
    (printf "sig-to-bound: ~n~a~n~n" sig-to-bound)
    (printf "relation-to-bound: ~n~a~n~n" relation-to-bound)
    (printf "all-atoms: ~n~a~n~n" all-atoms)
    (printf "total-bounds: ~n~a~n~n" total-bounds)
    (displayln "--------------------------"))


  #| Print to KodKod-CLI
    print configure
    declare univ size
    declare ints
    print Int sig (r0)
    print other sigs (r2 ... rm)
    print succ relation (r(m + 1))
    print other relations (r(m + 2) ... rn)
    print formula / assert formula (f0 ... fk)
    print solve
  |#

  ; Initializing our kodkod-cli process, and getting ports for communication with it
  (define backend (get-option run-spec 'backend))
  (define-values (stdin stdout shutdown is-running?) 
    (cond
      [(equal? backend 'kodkod)
       (kodkod:start-server)]
      [(equal? backend 'pardinus)
       (pardinus:start-server
        'stepper
        (Target? (Run-spec-target run-spec))
        (equal? 'temporal (get-option run-spec 'problem_type)))]
      [else (raise (format "Invalid backend: ~a" backend))]))

  (define-syntax-rule (kk-print lines ...)
    (kodkod:cmd 
      [stdin]
      lines ...))

  ; Print targets
  (define-syntax-rule (pardinus-print lines ...)
    (pardinus:cmd 
      [stdin]
      lines ...))

  ; Confirm that if the user is invoking a custom solver, that custom solver exists
  (define solverspec (cond [(symbol? (get-option run-spec 'solver))
                            (get-option run-spec 'solver)]
                           [else (string-append "\"" (get-option run-spec 'solver) "\"")]))
  (unless (or (symbol? (get-option run-spec 'solver))
              (file-exists? (get-option run-spec 'solver)))
    (raise-user-error (format "option solver specified custom solver (via string): ~a, but file did not exist." 
                              (get-option run-spec 'solver))))
  
  ; Print configure and declare univ size
  ; Note that target mode is passed separately, nearer to the (solve) invocation
  (define bitwidth (get-bitwidth run-spec)) 
  (pardinus-print
    (pardinus:configure (format ":bitwidth ~a :solver ~a :max-solutions 1 :verbosity 7 :skolem-depth ~a :sb ~a :core-gran ~a :core-minimization ~a :log-trans ~a ~a ~a"
                               bitwidth 
                               solverspec
                               (get-option run-spec 'skolem_depth)
                               (get-option run-spec 'sb) 
                               (get-option run-spec 'coregranularity)
                               (get-option run-spec 'core_minimization)
                               (get-option run-spec 'logtranslation)
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":min-trace-length ~a" (get-option run-spec 'min_tracelength))
                                   "")
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":max-trace-length ~a" (get-option run-spec 'max_tracelength))
                                   "")))
    (pardinus:declare-univ (length all-atoms)))

  ; Declare ints
  (define num-ints (expt 2 bitwidth))
  (pardinus-print
    (pardinus:declare-ints (range (- (/ num-ints 2)) (/ num-ints 2)) ; ints
                         (range num-ints)))                        ; indexes

  ; to-tupleset :: List<List<int>>, int -> tupleset
  (define (to-tupleset arity eles)
    (if (empty? eles)
        (if (@= arity 1)
            'none
            (pardinus:product 'none (to-tupleset (sub1 arity) eles)))
        (pardinus:tupleset #:tuples eles)))

  (define (get-atoms rel atom-names)
    (define atoms 
      (for/list ([tup atom-names])
        (for/list ([atom tup])
          ; Used to allow using ints in instances.
          (when (int-atom? atom)
            (set! atom (int-atom-n atom)))

          (unless (member atom all-atoms)
            (raise (format "atom (~a) not in all-atoms (~a)"
                           atom all-atoms)))
          (index-of all-atoms atom))))
    (define ret (to-tupleset (relation-arity rel) atoms))
    ret)

  (for ([rel (get-all-rels run-spec)]
        [bound total-bounds])    
    (pardinus-print
      (pardinus:declare-rel
       (if (node/expr/relation-is-variable rel)
           (pardinus:x (relation-name rel))
           (pardinus:r (relation-name rel)))
        (get-atoms rel (bound-lower bound))
        (get-atoms rel (bound-upper bound)))))

  ; Declare assertions
  (define all-rels (get-all-rels run-spec))

  (define (maybe-alwaysify fmla)
    (if (equal? 'temporal (get-option run-spec 'problem_type))
        (always/info (node-info fmla) fmla)
        fmla))
  
  ; Get and print predicates
  ; If in temporal mode, need to always-ify the auto-generated constraints but not the
  ;   predicates that come from users
  ; !!!
  (define raw-implicit-constraints
    (append (get-sig-size-preds run-spec total-bounds)
            (get-relation-preds run-spec)
            (get-extender-preds run-spec)
            relation-constraints
            break-preds))
  (define conjuncts-implicit-constraints
    (apply append (map maybe-and->list raw-implicit-constraints)))
  (define implicit-constraints
    (map maybe-alwaysify conjuncts-implicit-constraints))
  (define explicit-constraints
    (apply append (map maybe-and->list (Run-spec-preds run-spec)))) 
              
  (define run-constraints 
    (append explicit-constraints implicit-constraints))

  ; Run last-minute checks for errors  
  (for-each (lambda (c) (checkFormula run-spec c '())) run-constraints) 

  ; Keep track of which formula corresponds to which CLI assert
  ; for highlighting unsat cores. TODO: map back from CLI output
  ; constraints later
  (define core-map (make-hash))
  
  (for ([p run-constraints]
        [assertion-number (in-naturals)])
    (hash-set! core-map assertion-number p)
    (pardinus-print
      (pardinus:print-cmd-cont "(~a " (pardinus:f assertion-number))
      (translate-to-kodkod-cli run-spec p all-rels all-atoms '())
      (pardinus:print-cmd ")")
      (pardinus:assert (pardinus:f assertion-number))))

  (define target (Run-spec-target run-spec))
  (when target
    (for ([(rel-name atoms) (Target-instance target)])
      (define relation (hash-ref (get-relation-map run-spec) (symbol->string rel-name)))
      (define sig-or-rel
        (if (@= (relation-arity relation) 1)
            (get-sig run-spec relation)
            (get-relation run-spec relation)))

      (pardinus-print
        (pardinus:declare-target 
          (pardinus:r (relation-name relation))
          (get-atoms relation atoms))))

    (pardinus-print
      (pardinus:print-cmd "(target-option target-mode ~a)" (Target-distance target))))

  (define (format-statistics stats)
    (let* ([vars (assoc 'size-variables stats)]
           [prim (assoc 'size-primary stats)]
           [clauses (assoc 'size-clauses stats)]
           [tt (assoc 'time-translation stats)]
           [ts (assoc 'time-solving stats)]
           [tcx (assoc 'time-core stats)]
           [tcstr (if tcx (format " Core min (ms): ~a" tcx) "")])
      (format "#vars: ~a; #primary: ~a; #clauses: ~a~nTransl (ms): ~a; Solving (ms): ~a~a"
              vars prim clauses tt ts tcstr)))
  
  ; Print solve
  (define (get-next-model)
    (unless (is-running?)
      (raise "KodKod server is not running."))
    (pardinus-print (pardinus:solve))
    (define result (translate-from-kodkod-cli
                    'run 
                    (pardinus:read-solution stdout) 
                    all-rels 
                    all-atoms))

    
    ; Note on cores: if core granularity is high, Kodkod may return a formula we do not have an ID for
    (define (do-core-highlight loc)
      (if (is-drracket-linked?) 
          (do-forge-highlight loc CORE-HIGHLIGHT-COLOR 'core)
          (when (@>= (get-verbosity) VERBOSITY_LOW)        
            (printf "  Core contained location: ~a~n" (srcloc->string loc)))))  
    (when (and (Unsat? result) (Unsat-core result)) ; if we have a core
      (when (@>= (get-verbosity) VERBOSITY_DEBUG)
        (printf "core-map: ~a~n" core-map)
        (printf "core: ~a~n" (Unsat-core result)))
      (cond [(is-drracket-linked?) 
             (do-forge-unhighlight 'core)]
            [else
             (when (@>= (get-verbosity) VERBOSITY_LOW) 
               (printf "No DrRacket linked, could not highlight core. Will print instead.~n"))])
      (for-each do-core-highlight
                (filter-map (Î» (id)
                              (let ([fmla-num (if (string-prefix? id "f:") (string->number (substring id 2)) #f)])
                                (cond [(member fmla-num (hash-keys core-map))
                                       ; This is a formula ID and we know it
                                       ;(printf "LOC: ~a~n" (nodeinfo-loc (node-info (hash-ref core-map fmla-num))))
                                       (nodeinfo-loc (node-info (hash-ref core-map fmla-num)))]
                                      [else
                                       ; This is NOT a known formula id, but it's part of the core
                                       (printf "WARNING: Core also contained: ~a~n" id)
                                       #f])))
                            (Unsat-core result))))
    
    (when (@>= (get-verbosity) VERBOSITY_LOW)
      (displayln (format-statistics (if (Sat? result) (Sat-stats result) (Unsat-stats result)))))
    result)

  (define (model-stream [prev #f])
    (if (and prev
             (Unsat? prev))
        (letrec ([rest (stream-cons (prev) rest)])
          rest)
        (stream-cons (get-next-model) (model-stream))))

  (values (model-stream) 
          all-atoms 
          (Server-ports stdin stdout shutdown is-running?) 
          (Kodkod-current (length run-constraints) 0 0) 
          total-bounds))




; get-sig-info :: Run-spec -> Map<Symbol, bound>, List<Symbol>
; Given a Run-spec, assigns names to each sig, assigns minimum and maximum 
; sets of atoms for each, and find the total number of atoms needed (including ints).
(define (get-sig-bounds run-spec tbindings)

  ; Map<Symbol, int>
  (define curr-atom-number (make-hash))
  ; Sig -> Symbol
  (define (get-next-name sig)
    (define atom-number (add1 (hash-ref curr-atom-number (Sig-name sig) -1)))    
    (hash-set! curr-atom-number (Sig-name sig) atom-number)
    (define default-name (string->symbol (format "~a~a" (Sig-name sig) atom-number)))
;    (if (hash-has-key? tbindings (Sig-name sig))
;        (let ([bind-names (hash-ref tbindings (Sig-name sig))])                 
;          (if (@< atom-number (length bind-names))
;              (list-ref bind-names atom-number)
;              (if (member default-name bind-names) ; Avoid clash with user atom names
;                  (get-next-name sig)
;                  default-name)))          
        default-name)
  ;)
  
  ; Sig, int -> List<Symbol>
  ; TN changed this to always use the *lowest* unused atom names first
  ;   this matters if we're manufacturing an instance I2 from an instance I1 and the bounds
  ;   need to be identical regardless of how many of a given sig appeared in I1.
  (define (get-next-names sig num)
    (define bind-names (if (hash-has-key? tbindings (Sig-name sig))
                           (hash-ref tbindings (Sig-name sig))  ; user-defined names    
                           empty))
    (define default-names (for/list ([_ (range num)]) (get-next-name sig)))
    (define new-names (remove* bind-names default-names)) ; (remove* v-lst lst) removes from lst every element of v-lst
    (define n-new-needed (- num (length bind-names)))
    ;(printf "get-next-names; num=~a, bind-names: ~a, default-names: ~a, new-names: ~a, n-new-needed ~a~n"
    ;        num bind-names default-names new-names n-new-needed)
    (append bind-names (if (@> n-new-needed 0) (take new-names n-new-needed) empty)))

  ; Map<Symbol, List<Symbol>
  (define sig-to-lower (make-hash))
  ; Sig -> List<Symbol>
  (define (fill-lower sig)
    (define own-lower-int (Range-lower (get-scope run-spec sig)))
    (define children-lower (apply append (map fill-lower (get-children run-spec sig))))

    (define own-lower
      (let ([difference (@- own-lower-int (length children-lower))])        
        (if (@> difference 0)
            (remove-duplicates (append (get-next-names sig difference) children-lower))
            children-lower)))    
    (hash-set! sig-to-lower (Sig-name sig) own-lower)
    own-lower)

  ; Map<Symbol, List<List<Symbol>>
  (define sig-to-upper (make-hash))
  ; Sig, List<Symbol>? -> List<Symbol>
  (define (fill-upper-top sig)
    (define own-upper-int (Range-upper (get-scope run-spec sig)))
    (define own-lower (hash-ref sig-to-lower (Sig-name sig)))
    (define difference (@- own-upper-int (length own-lower)))    
    (when (@< difference 0)
      (raise (format "Illegal bounds for sig ~a. own-upper-int: ~a, own-lower: ~a"
                     (Sig-name sig)
                     own-upper-int
                     own-lower)))

    (define new-names (get-next-names sig difference))
    (define own-upper (append own-lower new-names))
    (hash-set! sig-to-upper (Sig-name sig) own-upper)

    (for ([child (get-children run-spec sig)]) (fill-upper-extender child own-upper))
    own-upper)

  (define (fill-upper-extender sig upper)
    (hash-set! sig-to-upper (Sig-name sig) upper)
    (for ([child (get-children run-spec sig)]) (fill-upper-extender child upper)))

  (define int-atoms
    (let* ([bitwidth (get-bitwidth run-spec)]
           [max-int (expt 2 (sub1 bitwidth))])
      (range (- max-int) max-int)))
  (hash-set! sig-to-lower 'Int int-atoms)
  (hash-set! sig-to-upper 'Int int-atoms)

  ; Start: Used to allow extending Ints.
  (for ([sig (get-children run-spec Int)])
    (hash-set! sig-to-lower (Sig-name sig) '())
    (hash-set! sig-to-upper (Sig-name sig) int-atoms))
  ; End: Used to allow extending Ints.

  (define top-level-sigs (get-top-level-sigs run-spec))
  
  (define sig-atoms (apply append
    (for/list ([sig top-level-sigs] 
               #:unless (equal? (Sig-name sig) 'Int))
      (fill-lower sig)
      (fill-upper-top sig))))

  (define all-atoms (append int-atoms sig-atoms))

  ; Map<Symbol, bound>
  (define bounds-hash
    (for/hash ([sig (get-sigs run-spec)])
      (let* ([name (Sig-name sig)]
             [rel (Sig-rel sig)]
             [lower (map list (hash-ref sig-to-lower name))]
             [upper (map list (hash-ref sig-to-upper name))])
        (values name (bound rel lower upper)))))

  (values bounds-hash all-atoms))

; get-relation-info :: Run-spec -> Map<Symbol, bound>
; Given a Run-spec, the atoms assigned to each sig, the atoms assigned to each name,
; and the starting relation name, assigns names to each relation
; and minimum and maximum sets of atoms for each relation.
(define (get-relation-bounds run-spec sig-to-bound)
  (define without-succ
    (for/hash ([relation (get-relations run-spec)]
               #:unless (equal? (Relation-name relation) 'succ))
      (define sigs (get-sigs run-spec relation))
      (define sig-atoms (map (compose (curry map car )
                                      bound-upper
                                      (curry hash-ref sig-to-bound )
                                      Sig-name) 
                             sigs))
      (define upper (apply cartesian-product sig-atoms))
      (define lower empty)
      (values (Relation-name relation) 
              (bound (Relation-rel relation) lower upper))))
  (define ints (map car (bound-upper (hash-ref sig-to-bound 'Int))))
  (define succ-tuples (map list (reverse (rest (reverse ints))) (rest ints)))
  (hash-set without-succ 'succ (bound succ succ-tuples succ-tuples)))

; get-sig-size-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig to restrict
; it to the correct lower/upper bound.
(define (get-sig-size-preds run-spec total-bounds) 
  (define max-int (expt 2 (sub1 (get-bitwidth run-spec))))
  (apply append
    (for/list ([sig (get-sigs run-spec)]
               #:unless (equal? (Sig-name sig) 'Int))
      (match-define (Range int-lower int-upper) (get-scope run-spec sig))
      
      (append
        (if (equal? int-lower 0)
            (list)
            (let ()
              (unless (@< int-lower max-int)
                (raise (format (string-append "Lower bound too large for given BitWidth; "
                                              "Sig: ~a, Lower-bound: ~a, Max-int: ~a")
                               sig int-lower (sub1 max-int))))
              (list (<= (int int-lower) (card (Sig-rel sig))))))
        (if (@not (Sig-extends sig))
            (list)
            (let ()
              (unless (@< int-upper max-int)
                (raise (format (string-append "Upper bound too large for given BitWidth; "
                                              "Sig: ~a, Upper-bound: ~a, Max-int: ~a")
                               sig int-upper (sub1 max-int))))
              (list (<= (card (Sig-rel sig)) (int int-upper)))))))))


; TN TODO
; For many implicit constraints, it's either difficult or impossible to
; produce a *single* location to blame the formula on. For instance,
; the constraint that forces two sigs to be disjoint from one another
; can't be blamed solely on one of the two sigs.
; Instead, keep track of lists of sites for each implicit formula.

; get-extender-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig which has extending Sigs so that:
; - if it is abstract, then it must equal the sum of its extenders
; -                    else it must contain the sum of its extenders
; - all extenders are pair-wise disjoint.
(define (get-extender-preds run-spec)
  (define sig-constraints (for/list ([sig (get-sigs run-spec)])
    ; get children information
    (define children-rels (map Sig-rel (get-children run-spec sig)))

    ; abstract and sig1, ... extend => (= sig (+ sig1 ...))
    ; not abstract and sig is parent of sig1 => (in sig1 sig)
    ; TODO: optimize by identifying abstract sigs as sum of children
    (define (abstract sig extenders)
      (if (@= (length extenders) 1)
          (= sig (car extenders))
          (= sig (+ extenders))))
    (define (parent sig1 sig2)
      (in sig2 sig1))
    (define extends-constraints 
      (if (and (Sig-abstract sig) (cons? (Sig-extenders sig)))
          (list (abstract (Sig-rel sig) children-rels))
          (map (curry parent (Sig-rel sig)) children-rels)))

    ; sig1 and sig2 extend sig => (no (& sig1 sig2))
    (define (disjoin-pair sig1 sig2)
      (no (& sig1 sig2)))
    (define (disjoin-list a-sig a-list)
      (map (curry disjoin-pair a-sig) a-list))
    (define (disjoin a-list)
      (if (empty? a-list)
          empty
          (append (disjoin-list (first a-list) (rest a-list))
                  (disjoin (rest a-list)))))
    (define disjoint-constraints (disjoin children-rels))

    (append extends-constraints disjoint-constraints)))

  ; combine all constraints together
  (apply append sig-constraints))

; get-relation-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Relation to ensure that it does not
; contain any atoms which don't populate their Sig.
(define (get-relation-preds run-spec)
  (for/list ([relation (get-relations run-spec)])
    (define sig-rels (map Sig-rel (get-sigs run-spec relation)))
    (in (Relation-rel relation) (-> sig-rels))))
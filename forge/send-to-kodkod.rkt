#lang racket

(require "sigs-structs.rkt")
(require "breaks.rkt")
(require "lang/ast.rkt")
(require "lang/bounds.rkt")
(require "shared.rkt"
         (prefix-in tree: "lazy-tree.rkt")
         "last-checker.rkt"
         "translate-to-kodkod-cli.rkt"
         "translate-from-kodkod-cli.rkt")
(require (prefix-in @ racket))
(require (prefix-in pardinus: "pardinus-cli/server/kks.rkt")
         (prefix-in pardinus: "pardinus-cli/server/server.rkt")
         (prefix-in pardinus: "pardinus-cli/server/server-common.rkt"))
(require (prefix-in kodkod: "kodkod-cli/server/kks.rkt")
         (prefix-in kodkod: "kodkod-cli/server/server.rkt")
         (prefix-in kodkod: "kodkod-cli/server/server-common.rkt"))
(require "server/eval-model.rkt")
(require "drracket-gui.rkt")

(provide send-to-kodkod)

(define no-version-printed-yet #t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;    Run Logic    ;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; send-to-kodkod :: Run-spec -> Stream<model>, List<Symbol>
; Given a Run-spec structure, processes the data and communicates it to KodKod-CLI;
; then produces a stream to produce instances generated by KodKod, 
; along with a list of all of the atom names for sig atoms.
(define (send-to-kodkod run-spec run-command)
  (define (raise-run-error message)
     (raise-syntax-error #f message run-command))

  ; Print version number, so students know to update
  (when (and no-version-printed-yet (@>= (get-verbosity) VERBOSITY_LOW))
    (set! no-version-printed-yet #f)
    (printf "Forge version: ~a~n" forge-version))
  
  ; Do relation breaks from declarations
  (define relation-constraints 
    (apply append
           (for/list ([relation (get-relations run-spec)])
             (match (Relation-breaker relation)
               [#f (list)]
               ['default (list)]
               ['pfunc (let* ([rel relation]
                              [sigs (map (lambda (sig-thunk) (sig-thunk))
                                         (Relation-sigs-thunks relation))]
                              [left-sig (get-sig run-spec (first sigs))]
                              [sig-rel left-sig])
                         (list (all ([s sig-rel])
                                 (lone (join s rel)))))]
               [other (break relation other)
                      (list)]))))

  (define-values (sig-to-bound relation-to-bound all-atoms)
    (get-bounds run-spec raise-run-error))

  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))
  
  ; Get new bounds and constraints from breaks
  (define-values (total-bounds break-preds)
    (let* ([sig-bounds (map (compose (curry hash-ref sig-to-bound )
                                     Sig-name)
                            (get-sigs run-spec))]
           [relation-bounds (map (compose (curry hash-ref relation-to-bound )
                                          Relation-name)
                                 (get-relations run-spec))]
           [total-bounds (append sig-bounds relation-bounds)]

           [sigs (get-sigs run-spec)]
           [sig-rels (filter (lambda (sig) (@not (equal? (Sig-name sig) 'Int))) sigs)]
           [upper-bounds (for/hash ([sig sigs]) 
                           (values sig
                                   (map car (bound-upper (hash-ref sig-to-bound (Sig-name sig))))))]
           [relations-store (for/hash ([relation (get-relations run-spec)]
                                       #:unless (equal? (Relation-name relation) 'succ))
                              (values relation (get-sigs run-spec relation)))]
           [extensions-store (for/hash ([sig sigs]
                                        #:when (Sig-extends sig))
                               (values sig (get-sig run-spec (Sig-extends sig))))])
      (constrain-bounds total-bounds sig-rels upper-bounds relations-store extensions-store)))
  (clear-breaker-state)

  (define sigs-and-rels
    (append (State-sig-order (Run-spec-state run-spec))
            (State-relation-order (Run-spec-state run-spec))))
  (set! total-bounds (map (lambda (name) 
                            (findf (lambda (b) 
                                     (equal? name (string->symbol (relation-name (bound-relation b)))))
                                   total-bounds)) 
                          sigs-and-rels))

  (when (@>= (get-verbosity) VERBOSITY_DEBUG)
    (displayln "--------------------------")
    (printf "Original PBindings: ~n~a~n~n" (Bound-pbindings (Run-spec-bounds run-spec)))
    (printf "sig-to-bound: ~n~a~n~n" sig-to-bound)
    (printf "relation-to-bound: ~n~a~n~n" relation-to-bound)
    (printf "all-atoms: ~n~a~n~n" all-atoms)
    (printf "total-bounds: ~n~a~n~n" total-bounds)
    (displayln "--------------------------"))


  #| Print to KodKod-CLI
    print configure
    declare univ size
    declare ints
    print Int sig (r0)
    print other sigs (r2 ... rm)
    print succ relation (r(m + 1))
    print other relations (r(m + 2) ... rn)
    print formula / assert formula (f0 ... fk)
    print solve
  |#

  ; Initializing our kodkod-cli process, and getting ports for communication with it
  (define backend (get-option run-spec 'backend))
  (define-values (stdin stdout shutdown is-running?) 
    (cond
      [(equal? backend 'kodkod)
       (kodkod:start-server)]
      [(equal? backend 'pardinus)
       (pardinus:start-server
        'stepper ; always a stepper problem (there is a "next" button)
        ; 'default, 'temporal, or 'target (tells Pardinus which solver to load,
        ;  and affects parsing so needs to be known at invocation time)
        (get-option run-spec 'problem_type))]
      [else (raise (format "Invalid backend: ~a" backend))]))

  (define-syntax-rule (kk-print lines ...)
    (kodkod:cmd 
      [stdin]
      lines ...))

  ; Print targets
  (define-syntax-rule (pardinus-print lines ...)
    (pardinus:cmd 
      [stdin]
      lines ...))

  ; Confirm that if the user is invoking a custom solver, that custom solver exists
  (define solverspec (cond [(symbol? (get-option run-spec 'solver))
                            (get-option run-spec 'solver)]
                           [else (string-append "\"" (get-option run-spec 'solver) "\"")]))
  (unless (or (symbol? (get-option run-spec 'solver))
              (file-exists? (get-option run-spec 'solver)))
    (raise-user-error (format "option solver specified custom solver (via string): ~a, but file did not exist." 
                              (get-option run-spec 'solver))))
  
  ; Print configure and declare univ size
  ; Note that target mode is passed separately, nearer to the (solve) invocation
  (define bitwidth (get-bitwidth run-spec)) 
  (pardinus-print
    (pardinus:configure (format ":bitwidth ~a :solver ~a :max-solutions 1 :verbosity 7 :skolem-depth ~a :sb ~a :core-gran ~a :core-minimization ~a :log-trans ~a ~a ~a"
                               bitwidth 
                               solverspec
                               (get-option run-spec 'skolem_depth)
                               (get-option run-spec 'sb) 
                               (get-option run-spec 'coregranularity)
                               (get-option run-spec 'core_minimization)
                               (get-option run-spec 'logtranslation)
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":min-trace-length ~a" (get-option run-spec 'min_tracelength))
                                   "")
                               (if (equal? 'temporal (get-option run-spec 'problem_type))
                                   (format ":max-trace-length ~a" (get-option run-spec 'max_tracelength))
                                   "")))
    (pardinus:declare-univ (length all-atoms)))

  ; Declare ints
  (define num-ints (expt 2 bitwidth))
  (pardinus-print
    (pardinus:declare-ints (range (- (/ num-ints 2)) (/ num-ints 2)) ; ints
                         (range num-ints)))                        ; indexes

  ; to-tupleset :: List<List<int>>, int -> tupleset
  (define (to-tupleset arity eles)
    (if (empty? eles)
        (if (@= arity 1)
            'none
            (pardinus:product 'none (to-tupleset (sub1 arity) eles)))
        (pardinus:tupleset #:tuples eles)))

  (define (get-atoms rel atom-names)
    (define atoms 
      (for/list ([tup atom-names])
        (for/list ([atom tup])
          ; Used to allow using ints in instances.
          (when (int-atom? atom)
            (set! atom (int-atom-n atom)))

          (unless (member atom all-atoms)
            (raise (format "atom (~a) not in all-atoms (~a)"
                           atom all-atoms)))
          (index-of all-atoms atom))))
    (define ret (to-tupleset (relation-arity rel) atoms))
    ret)

  (for ([rel (get-all-rels run-spec)]
        [bound total-bounds])
    (pardinus-print
      (pardinus:declare-rel
       (if (node/expr/relation-is-variable rel)
           (pardinus:x (relation-name rel))
           (pardinus:r (relation-name rel)))
        (get-atoms rel (bound-lower bound))
        (get-atoms rel (bound-upper bound)))))

  ; Declare assertions
  (define all-rels (get-all-rels run-spec))

  (define (maybe-alwaysify fmla)
    (if (equal? 'temporal (get-option run-spec 'problem_type))
        (always/info (node-info fmla) fmla)
        fmla))
  
  ; Get and print predicates
  ; If in temporal mode, need to always-ify the auto-generated constraints but not the
  ;   predicates that come from users
  ; !!!
  (define raw-implicit-constraints
    (append (get-sig-size-preds run-spec sig-to-bound)
            (get-relation-preds run-spec)
            (get-extender-preds run-spec)
            relation-constraints
            break-preds))
  (define conjuncts-implicit-constraints
    (apply append (map maybe-and->list raw-implicit-constraints)))
  (define implicit-constraints
    (map maybe-alwaysify conjuncts-implicit-constraints))
  (define explicit-constraints
    (apply append (map maybe-and->list (Run-spec-preds run-spec)))) 
              
  (define run-constraints 
    (append explicit-constraints implicit-constraints))

  ; Run last-minute checks for errors  
  (for-each (lambda (c) (checkFormula run-spec c '())) run-constraints) 

  ; Keep track of which formula corresponds to which CLI assert
  ; for highlighting unsat cores. TODO: map back from CLI output
  ; constraints later
  (define core-map (make-hash))
  
  (for ([p run-constraints]
        [assertion-number (in-naturals)])
    (hash-set! core-map assertion-number p)
    (pardinus-print
      (pardinus:print-cmd-cont "(~a " (pardinus:f assertion-number))
      (translate-to-kodkod-cli run-spec p all-rels all-atoms '())
      (pardinus:print-cmd ")")
      (pardinus:assert (pardinus:f assertion-number))))

  ; target-oriented model finding may not impose an initial target, but might
  ; be used just to implement custom "next" strategies
  (when (equal? 'target (get-option run-spec 'problem_type))
    (define target (Run-spec-target run-spec))    
    (when target
      (for ([(rel-name atoms) (Target-instance target)])
        (define relation (hash-ref (get-relation-map run-spec) (symbol->string rel-name)))
        (define sig-or-rel
          (if (@= (relation-arity relation) 1)
              (get-sig run-spec relation)
              (get-relation run-spec relation)))
        
        (pardinus-print
         (pardinus:declare-target 
          (pardinus:r (relation-name relation))
          (get-atoms relation atoms)))))

    ; Always say what mode; admittedly this won't always make sense if untargeted
    ; Conflate "target distance" declared with a concrete target and global mode
    (pardinus-print
     (pardinus:print-cmd "(target-option target-mode ~a)"
                         (if target
                             (Target-distance target)
                             (get-option run-spec 'target_mode)))))

  (define (format-statistics stats)
    (let* ([vars (assoc 'size-variables stats)]
           [prim (assoc 'size-primary stats)]
           [clauses (assoc 'size-clauses stats)]
           [tt (assoc 'time-translation stats)]
           [ts (assoc 'time-solving stats)]
           [tcx (assoc 'time-core stats)]
           [tcstr (if tcx (format " Core min (ms): ~a" tcx) "")])
      (format "#vars: ~a; #primary: ~a; #clauses: ~a~nTransl (ms): ~a; Solving (ms): ~a~a"
              vars prim clauses tt ts tcstr)))
  
  ; Print solve
  (define (get-next-model [mode ""])
    (unless (is-running?)
      (raise "KodKod server is not running."))
    (pardinus-print (pardinus:solve mode))
    (define result (translate-from-kodkod-cli
                    'run 
                    (pardinus:read-solution stdout) 
                    all-rels 
                    all-atoms))

    
    ; Note on cores: if core granularity is high, Kodkod may return a formula we do not have an ID for
    (define (do-core-highlight loc)
      (if (is-drracket-linked?) 
          (do-forge-highlight loc CORE-HIGHLIGHT-COLOR 'core)
          (when (@>= (get-verbosity) VERBOSITY_LOW)        
            (printf "  Core contained location: ~a~n" (srcloc->string loc)))))  
    (when (and (Unsat? result) (Unsat-core result)) ; if we have a core
      (when (@>= (get-verbosity) VERBOSITY_DEBUG)
        (printf "core-map: ~a~n" core-map)
        (printf "core: ~a~n" (Unsat-core result)))
      (cond [(is-drracket-linked?) 
             (do-forge-unhighlight 'core)]
            [else
             (when (@>= (get-verbosity) VERBOSITY_LOW) 
               (printf "No DrRacket linked, could not highlight core. Will print instead.~n"))])
      (for-each do-core-highlight
                (filter-map (Î» (id)
                              (let ([fmla-num (if (string-prefix? id "f:") (string->number (substring id 2)) #f)])
                                (cond [(member fmla-num (hash-keys core-map))
                                       ; This is a formula ID and we know it
                                       ;(printf "LOC: ~a~n" (nodeinfo-loc (node-info (hash-ref core-map fmla-num))))
                                       (nodeinfo-loc (node-info (hash-ref core-map fmla-num)))]
                                      [else
                                       ; This is NOT a known formula id, but it's part of the core
                                       (printf "WARNING: Core also contained: ~a~n" id)
                                       #f])))
                            (Unsat-core result))))
    
    (when (@>= (get-verbosity) VERBOSITY_LOW)
      (displayln (format-statistics (if (Sat? result) (Sat-stats result) (Unsat-stats result)))))
    result)

  ;(define (model-stream [prev #f])
  ;  (if (and prev
  ;           (Unsat? prev))
  ;      (letrec ([rest (stream-cons (prev) rest)])
  ;        rest)
  ;      (stream-cons (get-next-model) (model-stream))))

  (define (next-button type)
    (tree:make-node (get-next-model type) next-button))
  (define results
    (tree:make-node (get-next-model 'start) next-button))

  (values results 
          all-atoms 
          (Server-ports stdin stdout shutdown is-running?) 
          (Kodkod-current (length run-constraints) 0 0) 
          total-bounds))


(define (get-bounds run-spec raise-run-error)
  ; Send user defined partial bindings to breaks
  (map instance (hash-values (Bound-pbindings (Run-spec-bounds run-spec))))

  ; Get KodKod names, min sets, and max sets of Sigs and Relations
  (define-values (sig-to-bound all-atoms) ; Map<Symbol, bound>, List<Symbol>
    (get-sig-bounds run-spec raise-run-error))

  (define relation-to-bound ; Map<Symbol, bound>
    (get-relation-bounds run-spec sig-to-bound))

  (values sig-to-bound relation-to-bound all-atoms))


; get-sig-info :: Run-spec -> Map<Symbol, bound>, List<Symbol>
; Given a Run-spec, assigns names to each sig, assigns minimum and maximum 
; sets of atoms for each, and find the total number of atoms needed (including ints).
(define (get-sig-bounds run-spec raise-run-error)
  (define pbindings (Bound-pbindings (Run-spec-bounds run-spec)))
  (define (get-bound-lower sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding
          (map car (set->list (sbound-lower pbinding)))))
  (define (get-bound-upper sig)
    (define pbinding (hash-ref pbindings sig #f))
    (@and pbinding
          (sbound-upper pbinding)
          (map car (set->list (sbound-upper pbinding)))))

  (define scopes (Run-spec-scope run-spec))
  (define (get-scope-lower sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-lower scope)))
  (define (get-scope-upper sig)
    (define scope (hash-ref (Scope-sig-scopes scopes) (Sig-name sig) #f))
    (@and scope (Range-upper scope)))
  (define (get-scope-lower-default sig)
    (let ([actual (get-scope-lower sig)])
      (or actual
          (Range-lower (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))
  (define (get-scope-upper-default sig)
    (let ([actual (get-scope-upper sig)])
      (or actual
          (Range-upper (or (Scope-default-scope scopes)
                           DEFAULT-SIG-SCOPE)))))



  ; Map<Symbol, int>
  (define curr-atom-number (make-hash))
  ; Sig -> Symbol
  (define all-user-atoms 
    (apply append (for/list ([sig (get-sigs run-spec)]
                             #:when (hash-has-key? pbindings sig))
      (define bound (hash-ref pbindings sig))
      (map car (set->list (@or (sbound-upper bound) (sbound-lower bound)))))))
  (define (get-next-name sig)
    (define atom-number (add1 (hash-ref curr-atom-number (Sig-name sig) -1)))    
    (let loop ([atom-number atom-number])
      (hash-set! curr-atom-number (Sig-name sig) atom-number)
      (define new-name (string->symbol (format "~a~a" (Sig-name sig) atom-number)))
      (if (member new-name all-user-atoms)
          (loop (add1 atom-number))
          new-name)))
    
;    (if (hash-has-key? tbindings (Sig-name sig))
;        (let ([bind-names (hash-ref tbindings (Sig-name sig))])                 
;          (if (@< atom-number (length bind-names))
;              (list-ref bind-names atom-number)
;              (if (member default-name bind-names) ; Avoid clash with user atom names
;                  (get-next-name sig)
;                  default-name)))          
  ;)
  
  ; Sig, int -> List<Symbol>
  ; TN changed this to always use the *lowest* unused atom names first
  ;   this matters if we're manufacturing an instance I2 from an instance I1 and the bounds
  ;   need to be identical regardless of how many of a given sig appeared in I1.
  ; (define (get-next-names sig num)
  ;   (define bind-names (if (hash-has-key? tbindings (Sig-name sig))
  ;                          (hash-ref tbindings (Sig-name sig))  ; user-defined names    
  ;                          empty))
  ;   (define default-names (for/list ([_ (range num)]) (get-next-name sig)))
  ;   (define new-names (remove* bind-names default-names)) ; (remove* v-lst lst) removes from lst every element of v-lst
  ;   (define n-new-needed (- num (length bind-names)))

  ;   (append bind-names (if (@> n-new-needed 0) (take new-names n-new-needed) empty)))
  (define (generate-names sig num)
    (map (thunk* (get-next-name sig)) (range num)))



  (define lower-bounds (make-hash))
  (define upper-bounds (make-hash))

  (define (fill-lower-by-bound sig)
    (define children-lowers
      (apply append (map fill-lower-by-bound (get-children run-spec sig))))
    (define curr-lower (get-bound-lower sig))
    (define true-lower
      (remove-duplicates
        (append children-lowers
                (@or curr-lower (list)))))
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  (define (fill-lower-by-scope sig)
    (define children-lowers
      (apply append (map fill-lower-by-scope (get-children run-spec sig))))
    (define curr-lower-bound (get-bound-lower sig))
    (define curr-lower-scope (get-scope-lower-default sig))
    (define true-lower
      (remove-duplicates
        (if curr-lower-bound
            (append curr-lower-bound children-lowers)
            (append (generate-names sig (@- curr-lower-scope (length children-lowers))) children-lowers))))
    (hash-set! lower-bounds sig true-lower)
    true-lower)

  (define (fill-upper-with-bound sig [parent-upper #f])
    (define curr-upper (get-bound-upper sig))
    (if curr-upper
        (let ()
          (hash-set! upper-bounds sig curr-upper)
          (map (lambda (child) (fill-upper-with-bound child curr-upper))
               (get-children run-spec sig)))
        (fill-upper-past-bound sig parent-upper)))

  (define (fill-upper-past-bound sig parent-upper)
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))))
    (hash-set! upper-bounds sig parent-upper)
    (map (lambda (child) (fill-upper-past-bound child parent-upper))
         (get-children run-spec sig)))

  (define (fill-upper-no-bound sig shared)
    (when (get-bound-upper sig)
      (raise-run-error (format "Please specify an upper bound for ancestors of ~a." (Sig-name sig))))
    (define curr-lower (hash-ref lower-bounds sig))
    (hash-set! upper-bounds sig (append curr-lower shared))
    (map (lambda (child) (fill-upper-no-bound child shared))
         (get-children run-spec sig)))

  (define sig-atoms (list))
  (for ([root (get-top-level-sigs run-spec)]
        #:unless (equal? (Sig-name root) 'Int))
    (if (get-bound-upper root)
        (let ()
          (fill-lower-by-bound root)
          (fill-upper-with-bound root))
        (let ()
          (fill-lower-by-scope root)
          (define lower-size (length (hash-ref lower-bounds root)))
          (define upper-size
            (or (get-scope-upper root)
                (@max lower-size
                      (get-scope-upper-default root))))


          (define shared (generate-names root (@- upper-size lower-size)))
          (fill-upper-no-bound root shared)))
    (set! sig-atoms (append sig-atoms (hash-ref upper-bounds root))))

  (define int-atoms
    (let* ([bitwidth (get-bitwidth run-spec)]
           [max-int (expt 2 (sub1 bitwidth))])
      (range (- max-int) max-int)))
  (hash-set! lower-bounds (get-sig run-spec Int) int-atoms)
  (hash-set! upper-bounds (get-sig run-spec Int) int-atoms)

  ; Start: Used to allow extending Ints.
  (for ([sig (get-children run-spec Int)])
    (hash-set! lower-bounds (Sig-name sig) '())
    (hash-set! upper-bounds (Sig-name sig) int-atoms))
  ; End: Used to allow extending Ints.


  (define all-atoms (append int-atoms sig-atoms))

  ; Map<Symbol, bound>
  (define bounds-hash
    (for/hash ([sig (get-sigs run-spec)])
      (let* ([name (Sig-name sig)]
             [rel sig]
             [lower (map list (hash-ref lower-bounds sig))]
             [upper (map list (hash-ref upper-bounds sig))])
        (values name (bound rel lower upper)))))

  (values bounds-hash all-atoms))

; get-relation-info :: Run-spec -> Map<Symbol, bound>
; Given a Run-spec, the atoms assigned to each sig, the atoms assigned to each name,
; and the starting relation name, assigns names to each relation
; and minimum and maximum sets of atoms for each relation.
(define (get-relation-bounds run-spec sig-to-bound)
  (define without-succ
    (for/hash ([relation (get-relations run-spec)]
               #:unless (equal? (Relation-name relation) 'succ))
      (define sigs (get-sigs run-spec relation))
      (define sig-atoms (map (compose (curry map car )
                                      bound-upper
                                      (curry hash-ref sig-to-bound )
                                      Sig-name) 
                             sigs))
      (define upper (apply cartesian-product sig-atoms))
      (define lower empty)
      (values (Relation-name relation) 
              (bound relation lower upper))))
  (define ints (map car (bound-upper (hash-ref sig-to-bound 'Int))))
  (define succ-tuples (map list (reverse (rest (reverse ints))) (rest ints)))
  (hash-set without-succ 'succ (bound succ succ-tuples succ-tuples)))

; get-sig-size-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig to restrict
; it to the correct lower/upper bound.
(define (get-sig-size-preds run-spec sig-to-bound) 
  (define max-int (expt 2 (sub1 (get-bitwidth run-spec))))
  (apply append
    (for/list ([sig (get-sigs run-spec)]
               #:unless (equal? (Sig-name sig) 'Int))
      (match-define (bound rel bound-lower bound-upper) (hash-ref sig-to-bound (Sig-name sig)))
      (define-values (bound-lower-size bound-upper-size) (values (length bound-lower) (length bound-upper)))

      (match-define (Range int-lower int-upper) 
        (hash-ref (Scope-sig-scopes (Run-spec-scope run-spec)) (Sig-name sig) (Range #f #f)))

      (append
        (if (@and int-lower (@> int-lower bound-lower-size))
            (let ()
              (unless (@< int-lower max-int)
                (raise (format (string-append "Lower bound too large for given BitWidth; "
                                              "Sig: ~a, Lower-bound: ~a, Max-int: ~a")
                               sig int-lower (sub1 max-int))))
              (list (<= (int int-lower) (card sig))))
            (list))
        (if (@and int-upper (@< int-upper bound-upper-size))
            (let ()
              (unless (@< int-upper max-int)
                (raise (format (string-append "Upper bound too large for given BitWidth; "
                                              "Sig: ~a, Upper-bound: ~a, Max-int: ~a")
                               sig int-upper (sub1 max-int))))
              (list (<= (card sig) (int int-upper))))
            (list))))))


; TN TODO
; For many implicit constraints, it's either difficult or impossible to
; produce a *single* location to blame the formula on. For instance,
; the constraint that forces two sigs to be disjoint from one another
; can't be blamed solely on one of the two sigs.
; Instead, keep track of lists of sites for each implicit formula.

; get-extender-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Sig which has extending Sigs so that:
; - if it is abstract, then it must equal the sum of its extenders
; -                    else it must contain the sum of its extenders
; - all extenders are pair-wise disjoint.
(define (get-extender-preds run-spec)
  (define sig-constraints (for/list ([sig (get-sigs run-spec)])
    ; get children information
    (define children-rels (get-children run-spec sig))

    ; abstract and sig1, ... extend => (= sig (+ sig1 ...))
    ; not abstract and sig is parent of sig1 => (in sig1 sig)
    ; TODO: optimize by identifying abstract sigs as sum of children
    (define (abstract sig extenders)
      (if (@= (length extenders) 1)
          (= sig (car extenders))
          (= sig (+ extenders))))
    (define (parent sig1 sig2)
      (in sig2 sig1))
    (define extends-constraints 
      (if (and (Sig-abstract sig) (cons? (get-children run-spec sig)))
          (list (abstract sig children-rels))
          (map (curry parent sig) children-rels)))

    ; sig1 and sig2 extend sig => (no (& sig1 sig2))
    (define (disjoin-pair sig1 sig2)
      (no (& sig1 sig2)))
    (define (disjoin-list a-sig a-list)
      (map (curry disjoin-pair a-sig) a-list))
    (define (disjoin a-list)
      (if (empty? a-list)
          empty
          (append (disjoin-list (first a-list) (rest a-list))
                  (disjoin (rest a-list)))))
    (define disjoint-constraints (disjoin children-rels))

    (append extends-constraints disjoint-constraints)))

  ; combine all constraints together
  (apply append sig-constraints))

; get-relation-preds :: Run-spec -> List<node/formula>
; Creates assertions for each Relation to ensure that it does not
; contain any atoms which don't populate their Sig.
(define (get-relation-preds run-spec)
  (for/list ([relation (get-relations run-spec)])
    (define sig-rels (get-sigs run-spec relation))
    (in relation (-> sig-rels))))

#|

Algorithm (draft) for bound generation:

lowerBound1(sig)
    (explicit lower bound or {}) union
    union of lowerBound(sig.children)

lowerBound2(sig)
    if sig has lower tuple bound
        lower tuple bound union union of lowerBound(sig.children)
    else
        union of lowerBound(sig.children) + generate names to make lower scope of sig


fillUpper1(current, [parentUpper #f]):
    if partialBounds.upper has current
        current.upper = partialBounds.upper(current)
        map fillUpper1(_, current.upper) onto current.children
    else
        fillUpper2(current, parentUpper)

fillUpper2(current, parentUpper):
    assert partialBounds.upper not has current
    current.upper = parentUpper
    map fillUpper2(_, current.upper) onto current.children

fillUpper3(current, shared):
    assert partialBounds.upper not has current
    current.upper = current.lower + shared
    map fillUpper3(_, shared) onto current.children

for root in root sigs
    if root has tuple upper bound
        fillUpper1(root)

    else (root does not have tuple upper bound)
        upperSize = 
            root's numerical upper bound, if present
            maximum of #root.lower and default upper

        shared = generate(upperSize - #root.lower)
        fillUpper3(root, shared)

|#
